---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Gramática de datos

  - Recopilación
  - Importación
  - Exploración
    * Diccionario de variables
    * Niveles de agregación
    * Descripción univariada 
    * Identificando relaciones
    * Aproximación Visual (Visualización)
  - Filtrado y selección
    * Filtrado de observaciones
    * Selección de variables
    * Pivot, Reshape
    * Uniendo bases de datos
  - Muestreo, estimación, error estándar y confiabilidad
    * Diseño muestral
    * Estimación
    * Rendimiento
  - Transformación
    * Adecuación de formatos
    * Limpieza de texto
    * Creación de variables
    * Valores atípicos
    * Valores perdidos
    
## Recopilación

  + Depende de la fuente de información de interés

## Importación

Traer una base de datos externa y cargarla en el sistema de interés. En nuestro caso en R.

Hay varias librerías útiles para la importación

```{r}
rm(list=ls())
library(haven)# stata, spss, matlab, 
library(labelled) # permite trabajar con las etiquetas de bases de datos importadaS de stata o SPSS
library(readxl)# excel 
##################################
#importar la base de datos de las elecciones
bd20<-read.csv("C:/Users/PC18/Downloads/en2020.csv", sep="|")
getwd()
#
setwd("C:/Users/PC18/Documents/GitHub/big-data/data")#cambiar el directorio de trabajo
save(bd20,file="data/bd20.RData")#exportar a R
#cargar la base
rm(list = ls())
load("data/bd20.RData")
##censo
s1<-getwd()
setwd("C:/Users/PC18/Downloads/census-20230418T183736Z-001/census")
dir()
cs12d_8<-read_dta("DBdiscapacidad2012vf_8.dta")
cs12d_9<-read_dta("DBdiscapacidad2012vf_9.dta")
cs12m_8<-read_dta("DBmortalidad2012vf_8.dta")
cs12m_9<-read_dta("DBmortalidad2012vf_9.dta")
cs12p_8<-read_dta("DBpersonas2012vf_8.dta")
cs12p_9<-read_dta("DBpersonas2012vf_9.dta")
cs12v_8<-read_dta("DBvivienda2012vf_8.dta")
cs12v_9<-read_dta("DBvivienda2012vf_9.dta")
setwd(s1)
getwd()
save(cs12d_8,cs12d_9,cs12m_8,cs12m_9,cs12p_8,cs12p_9,cs12v_8,cs12v_9, file = "data/cs12.RData")
# Actividad: Realizar la importación de todas las bases de las encuestas a hogares y generar el RData correspondiente. (3:45)
setwd("C:/Users/PC18/Downloads/eh2021")
dir()
eh21de<-read_sav("EH2021_Defunciones.sav")
eh21di<-read_sav("EH2021_Discriminacion.sav")
eh21eq<-read_sav("EH2021_Equipamiento.sav")
eh21ga<-read_sav("EH2021_Gastos Alimentarios.sav")
eh21gn<-read_sav("EH2021_Gastos no Alimentarios.sav")
eh21p<-read_sav("EH2021_Persona.sav")
eh21sa<-read_sav("EH2021_Seguridad Alimentaria.sav")
eh21v<-read_sav("EH2021_Vivienda.sav")
setwd(s1)
save(eh21de,eh21di,eh21eq,eh21ga,eh21gn,eh21p,eh21sa,eh21v,file = "data/eh21.RData")
```

## Exploración

Meta data de la base de datos electoral.

  - **Población Objetivo:** Mesas electorales de las elecciones generales 2020
  - **Unidad de análisis:** Mesa electoral
  - **Unidad de información:** Acta electoral de la mesa
  - **Unidades agregadas:** Recinto, municipio, provincia, departamento
  - **Cobertura espacial:** Toda Bolivia
  - **Cobertura temporal:** 2020
  - **Cobertura temática:** Información geográfica, preferencias electorales
  - **Diseño estadístico:** No tiene, es un registro administrativo.
  
Meta data de la base de datos del censo:

  - **Población Objetivo:** Población y viviendas del 2012 en los departamentos Beni y Pando. 
  - **Unidad de análisis:** Personas, Viviendas
  - **Unidad de información:** Personas
  - **Unidades agregadas:** Viviendas, municipios, provincias y departamentos. 
  - **Cobertura espacial:** Departamentos de Beni y Pando
  - **Cobertura temporal:** 2012
  - **Cobertura temática:** Información geográfica, características de la vivienda, emigración internacional, mortalidad.
  - **Diseño estadístico:** Censo
  
Meta data de la base de datos de la encuesta a hogares 2021 (tarea).

  - **Población Objetivo:** 
  - **Unidad de análisis:** 
  - **Unidad de información:** 
  - **Unidad de agregadas:** 
  - **Cobertura espacial:** 
  - **Cobertura temporal:** 
  - **Cobertura temática:** 
  - **Diseño estadístico:**   

```{r}
rm(list = ls())
load("data/bd20.RData")
load("data/cs12.RData")
```

### Diccionario de variables

Es un listado de las variables y sus características de formato y alguna información adicional. Lo mas importante es saber que variables son cualitativas y cuales cuantitativas.

Cuando existen muchas bases de datos dentro de nuestro dataset, o cuando tenemos varias unidades agregadas es importante identificar la variable de identificación única de las unidades de análisis ($KEY$).

  - Electoral, mesa: Codigo.MESA
  - Censo, persona, vivienda: , vivienda es la variable llave
  
```{r}
names(bd20)
length(unique(bd20$Codigo.MESA))
length(unique(bd20$Codigo.RECINTO))
length(unique(bd20$Nombre.RECINTO))
length(unique(bd20$Codigo.DEPARTAMENTO))

length(unique(cs12v_8$llave))
length(unique(cs12p_8$llave))
length(unique(cs12p_8$iviv))
length(unique(cs12p_8$iind))

str(bd20)#estrucutra 
str(bd20$VALIDOS)
class(bd20$VALIDOS)
class(bd20$Codigo.DEPARTAMENTO)
class(bd20$Nombre.DEPARTAMENTO)
class(bd20$Codigo.DEPARTAMENTO)

#STATA, SPSS
str(cs12p_9)
str(cs12p_9$p23)
aux<-attributes(cs12p_9)
aux$names
library(labelled)
var_label(cs12p_9) # etiqueta de la variable (descripción)
val_labels(cs12p_9$p23) # Etiquetas de variables codificadas

to_factor(cs12p_9$p23)
cs12p_9$p23
bd_axu<-to_factor(cs12p_8)
#tarea para la siguiente clase, armar bases de datos que contenga el diccionario de las bases de datos del censo 
```

### Nombre de las variables

```{r}
load("data/bd20.RData")
names(bd20)
```

Recomendaciones para los nombres de variables:

  - Usar solo mayúsculas o minúsculas
  - Evitar los espacios
  - Evitar iniciar con números, o que el nombre de la variable sea un número
  - Evitar símbolos y caracteres, evitar los acentos
  - El nombre de la variable debiera ser corto (3 a 10) e informativo
  
Por ejemplo: para la variable edad:

  - ¿Cuál es su edad?
  - edad
  - edad2000
  - age

```{r}
names(bd20)
names(bd20)<-tolower(names(bd20))
#toupper(names(bd20))
library(dplyr)#gramática de dato

bd20 %>% rename(ipais=codigo.pais,
                dpais=nombre.pais)

bd20<-bd20 %>% rename(ipais=codigo.pais,
                dpais=nombre.pais)
names(bd20)
```

### Reportes básicos

```{r}
sum(bd20$cc)
max(bd20$cc)
min(bd20$cc)
mean(bd20$cc)

bd20 %>% summarise(Total=sum(cc),
                   Minimo=min(cc),
                   Maximo=max(cc),
                   Promedio=mean(cc))

bd20 %>% summarise_at(vars(adn:pan.bol),sum)
bd20 %>% summarise_at(vars(adn:pan.bol), 
                      quantile, probs=c(0.05,0.95))
```

### Niveles de agregación

La base de datos puede tener una unidad de investigación **elemental**, pero, puede tener también información de unidades de interés mas grandes, es decir; que agreguen a los unidades elementales.

> Problema: Construir una base de datos a nivel de los recintos, con la información de los votos para el MAS, CC, VALIDOS.

```{r}
#departamento
t1<-bd20 %>% group_by(depto=nombre.departamento) %>% summarise(cc=sum(cc),mas=sum(mas.ipsp),val=sum(validos))
#latex
library(xtable)
xtable(t1)
#############
t2<-bd20 %>% group_by(depto=nombre.departamento,
         prov=nombre.provincia) %>% summarise(cc=sum(cc),mas=sum(mas.ipsp),val=sum(validos))
t2

t3<-bd20 %>% group_by_at(vars(codigo.departamento:nombre.recinto)) %>% summarise(cc=sum(cc),mas=sum(mas.ipsp),val=sum(validos))
```

### Descripción univariada 

El objetivo es conocer estadísticas básicas de cada variable.

  + Cualitativas: Conteo, %
  + Cuantitativas: tendencia central, variabilidad, medidas de forma, densidad.

Ejemplo: Obtener la cantidad de mesas y recintos electorales por departamento.
  
```{r}
t4<-bd20 %>% group_by(nombre.departamento) %>% count() 
t4

bd20 %>% group_by(nombre.departamento) %>%  summarise(mesas=n(),val=sum(validos))
#recintos
t3%>% group_by(nombre.departamento) %>% count() 

bd20 %>% group_by(nombre.departamento,codigo.recinto) %>% summarise(sum(cc)) %>% group_by(nombre.departamento) %>% count()

#cuanti

bd20 %>% summarise(mean(mas.ipsp),sd(mas.ipsp), max(mas.ipsp))
#mean, median, sd, var, min, max, quantile

cv<-function(x){
  y<-sd(x)/mean(x)
  return(y)
}
bd20 %>% summarise(cv(mas.ipsp),cv(cc))

```

### Aproximación Visual (Visualización)

Al hacer un gráfico se debe definir 3 aspectos:

  1. Información (dataset)
  2. Estética (componentes)
  3. Geometría 

```{r}
library(ggplot2) # gramática de gráficos
#univariantes
# + +
ggplot(bd20,aes(cc))+geom_boxplot()
ggplot(bd20,aes(cc))+geom_density()
ggplot(bd20,aes(mas.ipsp))+geom_density()
ggplot(bd20,aes(cc))+geom_histogram()

ggplot(bd20,aes(nombre.departamento))+geom_bar()
# CUANTI VS CUANTI
ggplot(bd20,aes(cc,mas.ipsp)) + geom_point()

ggplot(t3,aes(cc,mas)) + geom_point()

ggplot(t3,aes(cc,mas)) + geom_point(col="darkred")

ggplot(t3,aes(cc,mas,col=nombre.departamento)) + geom_point()

ggplot(t3,aes(cc,mas,
              col=nombre.departamento,
              size=mas)) + geom_point()

plot(t3$cc,t3$mas)
```

## Filtrado y selección

### Filtrado de observaciones

El filtrado se refiere a seleccionar casos (filas) que cumplen una determinada condición. En la librería dplyr el comando filter se utiliza para esto.

Para las condiciones en R se utilizan los operadores lógicos:

  + Igualdad "=="
  + Distinto "!="
  + ó lógico "|"
  + y lógico "&" 
  + Negación "!"
  + Desigualdad "<,>,>=,<="
  + (Which) Múltiples condiciones (|) "%in%"
  
Crear bases de datos que contengan:

  - Bases de datos de las mesas por departamento
  - Bases de datos de los departamentos distintos al eje central
  - BD del municipio de El Alto
  - BD del municipio donde el MAS obtenga en términos relativos la mayor votación
  - BD del municipio donde el CC obtenga en términos relativos la mayor votación
  - BD del municipio donde el Creemos obtenga en términos relativos la mayor votación
  - BD del municipio con mayor similitud a los resultados nacionales (en términos relativos)
  
```{r}
rm(list=ls())
library(dplyr)
load("data/bd20.RData")
names(bd20)<-tolower(names(bd20))
names(bd20)

table(bd20$nombre.departamento)
table(bd20$codigo.departamento)
# BENI
bd_bn<-bd20 %>% filter(nombre.departamento=="BENI")
#- Bases de datos de las mesas por departamento
aux<-unique(bd20$nombre.departamento)
bd_d<-list()
r<-1
for(i in aux){
  bd_d[[r]]<-bd20 %>% filter(nombre.departamento==i)
  r<-r+1
}
# - Bases de datos de los departamentos distintos al eje central
aux[c(2,3,7)]

bd20 %>% 
filter(!(nombre.departamento %in% aux[c(2,3,7)])) %>% group_by(nombre.departamento) %>% count()

bd1<-bd20 %>% 
filter(!(nombre.departamento %in% aux[c(2,3,7)])) 
# - BD del municipio de El Alto
aux1<-sort(unique(bd20$nombre.municipio))
bdea<-bd20 %>% filter(codigo.municipio=="20105")
bdea2<-bd20 %>% filter(nombre.municipio==aux1[95])

names(bd20)
7
bdmun<-bd20 %>% group_by(codigo.municipio,nombre.municipio) %>% summarise_at(vars(adn:validos),sum)

maxmas<-max(bdmun$mas.ipsp/bdmun$validos)
pmas<-bdmun$mas.ipsp/bdmun$validos==maxmas
bdmun$codigo.municipio[pmas]
bdmun$nombre.municipio[pmas]

maxcc<-max(bdmun$cc/bdmun$validos)
pcc<-bdmun$cc/bdmun$validos==maxcc
bdmun$codigo.municipio[pcc]
bdmun$nombre.municipio[pcc]

maxcre<-max(bdmun$creemos/bdmun$validos)
pcre<-bdmun$creemos/bdmun$validos==maxcre
bdmun$codigo.municipio[pcre]
bdmun$nombre.municipio[pcre]
#  - BD del municipio donde el MAS obtenga en términos relativos la mayor votación
bd20 %>% filter(codigo.municipio=="31304")
#  - BD del municipio donde el CC obtenga en términos relativos la mayor votación
bd20 %>% filter(codigo.municipio=="50101")
#  - BD del municipio donde el Creemos obtenga en términos relativos la mayor votación
bd20 %>% filter(codigo.municipio=="70601")

BD del municipio con mayor similitud a los resultados nacionales (en términos relativos)
```

### Selección de variables

Simplemente se refiere a la selección de variables, este proceso se recomienda realizarlo antes del modelo, ya que libera memoria y optimiza los tiempos de procesamiento, además, nos permite enfocarnos en las variables de interés. En la librería dplyr el comando es select.

```{r}
bd20 %>% select(codigo.mesa,validos)
bd20 %>% select(-codigo.pais)
bd20 %>% select(-codigo.pais, -codigo.departamento)
bd20 %>% select_at(vars(adn:validos))

bd20 %>% select(starts_with("nombre")) %>% names()
bd20 %>% select(starts_with("codigo")) %>% names()
bd20 %>% select(!starts_with("codigo")) %>% names()
bd20 %>% select(contains(".")) %>% names()
bd20 %>% select(!contains(".")) %>% names()
```

Extra para ordenar la base de datos se utiliza el comando arrange.

```{r}
bdmun %>% head()
bdmun %>% arrange(nombre.municipio) %>% head()
bdmun %>% arrange(desc(nombre.municipio)) %>% head()

bdmun %>% arrange(cc,mas.ipsp) %>% select(cc,mas.ipsp) %>% head()
```

## Transformación

Se refiere a cambios en las variables o la base de datos. A nivel de las variables las transformaciones más comunes son:

  - Adecuación de formatos
  - Limpieza de texto
  - Creación de variables
  - Valores atípicos
  - Valores perdidos

### Adecuación de formatos

Se refiere a cambiar la clase o el tipo de formato de una variable.

```{r}
library(haven)
library(dplyr)
load("data/cs12.RData")
names(cs12v_8)
class(cs12v_8$p04)
aux<-as.factor(cs12v_8$p04)
mean(cs12v_8$p04, na.rm = T)
mean(aux, na.rm = T)
```

  - as.factor, as.character, as.numeric

```{r}
cs12v_8<-cs12v_8 %>% mutate(p04_1=as.factor(p04))
class(cs12v_8$p04_1)

cs12v_8<-cs12v_8 %>% mutate(p04_1=as.factor(p04),
       p04_2=as_factor(p04),
       p04_3=as.character(p04))

cs12v_8 %>% select(p04,p04_1,p04_2,p04_3) %>% head()

cs12v_8 %>% filter(p04==1) %>% group_by(p03) %>% count() 

cs12v_8 %>% filter(p04_2=="Si") %>% group_by(p03) %>% count() 
```

### Creación de variables

Existen diferentes alternativas, estas normalmente deben estar orientadas a un indicador o para facilitar el manejo de alguna variable.

```{r}
cs12v_8 %>% mutate(aux=1) %>% summarise(sum(aux))

cs12v_8<-cs12v_8 %>% mutate(revoque=(p04==1)) 
cs12v_8$revoque
class(cs12v_8$revoque)
cs12v_8 %>% summarise(mean(revoque,na.rm = T))
cs12v_8 %>% summarise(sum(revoque,na.rm = T))
cs12v_8$urbrur

cs12v_8<-cs12v_8 %>% mutate(rural=urbrur==2)

cs12v_8 %>% filter(rural==T) %>% summarise(mean(revoque,na.rm = T))

class(cs12v_8$p07)

cs12v_8<-cs12v_8 %>% mutate(agua=(p07==1|p07==2|p07==4),
                   agua2=( p07 %in% c(1,2,4)))

cs12v_8 %>% mutate(agua=(p07==1|p07==2|p07==4),
                   agua2=(p07 %in% c(1,2,4))) %>% summarise(mean(agua,na.rm = T), mean(agua2,na.rm = T))

mean(cs12v_8$agua, na.rm = T)
mean(cs12v_8$agua2, na.rm = T)

prop.table(table(cs12v_8$p07))[c(1,2,4)]
sum(prop.table(table(cs12v_8$p07))[c(1,2,4)])
```

Tarea: 

  - Tasa de masculinidad por hogar y provincia. (promedio a nivel de hogar) 
  - Promedio de la tasa de dependencia. (<18,>=60)
  - Promedio de viviendas con revoque y agua mejorada según el sexo del jefe/a del hogar. (inner. left. right, merge)
  - En el caso de las preguntas p04 y p07 a que se deben los NA. Son valores perdidos, son valores no aplica, etc.

### Valores perdidos

```{r}
x1<-c(1,2,3,NA,NA,4,5)
x2<-c(NA,2,NA,8,9,4,5)
bd<-data.frame(x1,x2)
bd
mean(bd$x1,na.rm=T)
mean(bd$x2,na.rm=T)
colMeans(bd,na.rm = T)
bd2<-na.omit(bd)
colMeans(bd2)

mx1<-mean(bd$x1,na.rm=T)
mx2<-mean(bd$x2,na.rm=T)

bd$x1[is.na(bd$x1)]<-mx1
bd$x2[is.na(bd$x2)]<-mx2

bd0<-bd
bd0
colMeans(bd)
```

### Valores atípicos

  - Hacer la diferencia entre valores atípicos univariantes de los multivariantes
  - En lo univariante
    + Transformación logarítmica
    + Partición de la base de datos (**estables**, atípicos). Se puede utilizar los quantiles (p99, p01) existen otros algoritmos (bacon)
  - En lo multivariante
    + Componentes principales (detección). Primer componente.
    + Métodos de agrupamiento (kcenter, "k")

### Uniendo bases de datos

La unión de bases de datos se puede entender en dos direcciones:

  + Se añaden casos (filas)
  + Se añaden variables (columnas)

```{r}
rm(list = ls())
library(dplyr)
load("data/cs12.RData")
cs12p<-cs12p_8 %>% bind_rows(cs12p_9) #apilar, append
names(cs12p)
cs12p %>% group_by(desc_idep,p24) %>% summarise(mean(p25),max(p25))

aux<-cs12p %>% group_by(p25) %>% count()

plot(aux$p25,aux$n,type = "h")
```

Para apilar las bases de datos, se debe asegurar que estas tengan las mismas variables e información adicional.

Promedio de viviendas con revoque y agua mejorada según el sexo del jefe/a del hogar. (inner. left. right, merge)

```{r}
library(haven)
aux1<-cs12p_8 %>% select(llave, p23, p24) %>% filter(p23 == 1)
length(unique(aux1$llave))
# explorar las llaves repetidas
# filtrar las llaves que no son únicas

table(cs12v_8$p01)
v8<-cs12v_8 %>% filter(p01 %in% 1:5)
table(v8$p02)
v8 %>% filter(p02%in% c(0,3,4,5)) %>% View()
v8<-v8 %>% filter(p02 %in% 0:2)
table(is.na(v8$p03))
```


### Pivot, Reshape


### Identificando relaciones

El objetivo es tener una medida estadística que nos indique algo sobre la relación existente entre 2 o más variables.

  - Cuali vs cuali

```{r}
library(haven)
# Área pobreza
table(eh21p$area,eh21p$p0)
chisq.test(table(eh21p$area,eh21p$p0))
```

Test de independencia $/chi^2$

  - H0: Independencia

Cuanti vs cuanti: Lo más útil y práctico es hacer una **correlación**, sin embargo, lo que se estudia es una relación lineal, además son relaciones *casuales*


## Muestreo, estimación, error estándar y confiabilidad
### Diseño muestral
### Estimación
### Rendimiento
## Transformación
### Adecuación de formatos
### Limpieza de texto
### Creación de variables
### Valores atípicos
### Valores perdidos